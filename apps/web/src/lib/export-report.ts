/**
 * Export report utilities for generating downloadable reports
 */

export interface ScanResults {
  scanId: string
  repoUrl: string
  branch: string
  analyzedAt: string
  languages?: any
  riskScores?: any
  readmeAnalysis?: any
  circularDependencies?: any
  deadCode?: any
  complexityMetrics?: any
  dependencies?: any
  explanations?: any
}

/**
 * Generate a Markdown report from scan results
 */
export function generateMarkdownReport(scan: ScanResults): string {
  const lines: string[] = []
  
  // Header
  lines.push(`# Repository Analysis Report`)
  lines.push('')
  lines.push(`**Repository:** ${scan.repoUrl}`)
  lines.push(`**Branch:** ${scan.branch}`)
  lines.push(`**Analyzed:** ${new Date(scan.analyzedAt).toLocaleString()}`)
  lines.push(`**Scan ID:** ${scan.scanId}`)
  lines.push('')
  
  // Risk Overview
  if (scan.riskScores) {
    lines.push('## Risk Overview')
    lines.push('')
    lines.push(`| Category | Score |`)
    lines.push(`|----------|-------|`)
    lines.push(`| Overall | ${scan.riskScores.overall || 0}/100 |`)
    lines.push(`| Complexity | ${scan.riskScores.complexity || 0}/100 |`)
    lines.push(`| Security | ${scan.riskScores.security || 0}/100 |`)
    lines.push(`| Maintainability | ${scan.riskScores.maintainability || 0}/100 |`)
    lines.push('')
  }
  
  // Languages
  if (scan.languages?.languages) {
    lines.push('## Languages Detected')
    lines.push('')
    const langs = scan.languages.languages
    for (const [lang, pct] of Object.entries(langs)) {
      const percentage = typeof pct === 'number' ? (pct * 100).toFixed(1) : pct
      lines.push(`- **${lang}**: ${percentage}%`)
    }
    lines.push('')
  }
  
  // README Analysis
  if (scan.readmeAnalysis) {
    lines.push('## README Quality')
    lines.push('')
    lines.push(`**Score:** ${scan.readmeAnalysis.score}/100`)
    lines.push('')
    
    if (scan.readmeAnalysis.suggestions?.length > 0) {
      lines.push('### Improvement Suggestions')
      lines.push('')
      for (const suggestion of scan.readmeAnalysis.suggestions) {
        lines.push(`- ${suggestion.message || suggestion}`)
      }
      lines.push('')
    }
  }
  
  // Circular Dependencies
  if (scan.circularDependencies?.cycles?.length > 0) {
    lines.push('## Circular Dependencies')
    lines.push('')
    lines.push(`**Found ${scan.circularDependencies.cycles.length} circular dependency chain(s)**`)
    lines.push('')
    for (const cycle of scan.circularDependencies.cycles.slice(0, 5)) {
      lines.push(`- ${cycle.join(' â†’ ')}`)
    }
    if (scan.circularDependencies.cycles.length > 5) {
      lines.push(`- ... and ${scan.circularDependencies.cycles.length - 5} more`)
    }
    lines.push('')
  }
  
  // Dead Code
  if (scan.deadCode?.has_dead_code) {
    lines.push('## Dead Code Analysis')
    lines.push('')
    const stats = scan.deadCode.statistics
    lines.push(`- **Unused Exports:** ${stats.total_unused_exports} (${stats.unused_export_percentage}%)`)
    lines.push(`- **Unused Imports:** ${stats.total_unused_imports || 0}`)
    lines.push(`- **Affected Files:** ${stats.affected_files}`)
    lines.push('')
  }
  
  // Complexity
  if (scan.complexityMetrics?.statistics) {
    lines.push('## Complexity Metrics')
    lines.push('')
    const stats = scan.complexityMetrics.statistics
    lines.push(`- **Total Functions:** ${stats.totalFunctions}`)
    lines.push(`- **Avg Cyclomatic Complexity:** ${stats.avgCyclomatic}`)
    lines.push(`- **Avg Cognitive Complexity:** ${stats.avgCognitive}`)
    lines.push(`- **High Complexity Functions:** ${stats.highComplexityCount}`)
    lines.push('')
  }
  
  // Dependencies
  if (scan.dependencies?.packages?.length > 0) {
    lines.push('## Dependencies')
    lines.push('')
    const deps = scan.dependencies.packages
    const prodDeps = deps.filter((d: any) => !d.isDev)
    const devDeps = deps.filter((d: any) => d.isDev)
    
    lines.push(`- **Production:** ${prodDeps.length}`)
    lines.push(`- **Development:** ${devDeps.length}`)
    lines.push('')
  }
  
  // AI Summary
  if (scan.explanations?.overview) {
    lines.push('## AI Analysis Summary')
    lines.push('')
    lines.push(scan.explanations.overview)
    lines.push('')
  }
  
  // Footer
  lines.push('---')
  lines.push('')
  lines.push('*Generated by RepoLens*')
  
  return lines.join('\n')
}

/**
 * Generate JSON report from scan results
 */
export function generateJsonReport(scan: ScanResults): string {
  return JSON.stringify(scan, null, 2)
}

/**
 * Download content as a file
 */
export function downloadFile(content: string, filename: string, mimeType: string) {
  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * Export scan results as Markdown
 */
export function exportAsMarkdown(scan: ScanResults) {
  const content = generateMarkdownReport(scan)
  const repoName = scan.repoUrl.split('/').slice(-2).join('-')
  const filename = `repolens-report-${repoName}-${scan.scanId.slice(0, 8)}.md`
  downloadFile(content, filename, 'text/markdown')
}

/**
 * Export scan results as JSON
 */
export function exportAsJson(scan: ScanResults) {
  const content = generateJsonReport(scan)
  const repoName = scan.repoUrl.split('/').slice(-2).join('-')
  const filename = `repolens-report-${repoName}-${scan.scanId.slice(0, 8)}.json`
  downloadFile(content, filename, 'application/json')
}
